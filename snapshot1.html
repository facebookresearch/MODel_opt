
<!DOCTYPE html>
<html>
<head></head>
<body>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7.7.0/+esm";
import {schemeTableau10} from "https://cdn.skypack.dev/d3-scale-chromatic@3";
import {axisLeft} from "https://cdn.skypack.dev/d3-axis@3";
import {scaleLinear} from "https://cdn.skypack.dev/d3-scale@4";
import {zoom, zoomIdentity} from "https://cdn.skypack.dev/d3-zoom@3";
import {brushX} from "https://cdn.skypack.dev/d3-brush@3";

let alloc_data = {"actions": [0, 1, 2, 3, 2, 1, 4, 5, 6, 7, 6, 5, 4, 8, 9, 10, 11, 10, 9, 3, 0, 7, 8, 11], "elements": [{"size": 10485760, "info": 5}, {"size": 10485760, "info": 7}, {"size": 10485760, "info": 7}, {"size": 20971520, "info": 8}, {"size": 10485760, "info": 12}, {"size": 10485760, "info": 12}, {"size": 10485760, "info": 12}, {"size": 31457280, "info": 13}, {"size": 20971520, "info": 17}, {"size": 5242880, "info": 21}, {"size": 31457280, "info": 22}, {"size": 10485760, "info": 23}], "suffix_table": [[4, null], [2, 0], [3, 1], [2, 2], [1, 3], [0, 4], [5, 3], [0, 6], [6, 6], [8, 1], [2, 9], [7, 10], [0, 11], [9, 11], [11, 1], [2, 14], [10, 15], [6, 16], [14, 1], [2, 18], [13, 19], [12, 20], [9, 20], [0, 20]], "string_table": ["10.0MiB allocation", "memory_debugging_tensor.py:198:forward", "/private/home/melhoushi/miniconda3/envs/torch_nightly/lib/python3.8/site-packages/torch/nn/modules/module.py:1501:_call_impl", "memory_debugging_tensor.py:190:forward", "memory_debugging_tensor.py:228:<module>", "memory_debugging_tensor.py:199:forward", "20.0MiB allocation", "memory_debugging_tensor.py:209:forward", "memory_debugging_tensor.py:191:forward", "30.0MiB allocation", "memory_debugging_tensor.py:204:forward", "memory_debugging_tensor.py:192:forward", "5.0MiB allocation", "memory_debugging_tensor.py:214:forward", "memory_debugging_tensor.py:193:forward"], "initially_allocated": []}

function process_alloc_data(fraction_of_memory_reported=1) {
    let current = []
    let current_data = []
    let data = []
    let max_size = 0

    let total_mem = 0
    let timestep = 0

    let max_at_time = []
    function advance(n, max) {
        timestep += n
        for (let i = 0; i < n; i++) {
            max_at_time.push(max)
        }
    }

    let mini_points = []

    let sizes = alloc_data.elements.map(x => x.size).sort((x, y) => y - x)
    let total_size = sizes.reduce((x, y) => x + y)
    const memory_threshold = fraction_of_memory_reported * total_size
    let total_seen = 0
    let memory_threshold_size = 0

    for (const [i, size] of sizes.entries()) {
        total_seen += size
        if (total_seen > memory_threshold) {
            memory_threshold_size = size
            break
        }
    }

    function add_allocation(elem) {
        let size = alloc_data.elements[elem].size
        current.push(elem)
        let e = {elem: elem, timesteps: [timestep], offsets: [total_mem], size: alloc_data.elements[elem].size}
        current_data.push(e)
        data.push(e)
        total_mem += size
    }

    for (const elem of alloc_data.initially_allocated) {
        add_allocation(elem)
    }

    for (const action of alloc_data.actions) {
        const elem = action
        const idx = current.findIndex(x => x === elem)
        const size = alloc_data.elements[elem].size
        if (size < memory_threshold_size) {
            continue
        }
        // first time we see an action we add it
        // second time we remove it
        if (idx == -1) {
            add_allocation(elem)
            advance(1, total_mem)
        } else {
            advance(1, total_mem)
            const removed = current_data[idx]
            removed.timesteps.push(timestep)
            removed.offsets.push(removed.offsets.at(-1))
            current.splice(idx, 1)
            current_data.splice(idx, 1)

            if (idx < current.length) {
                for (let j = idx; j < current.length; j++) {
                    const e = current_data[j]
                    e.timesteps.push(timestep)
                    e.offsets.push(e.offsets.at(-1))
                    e.timesteps.push(timestep + 3)
                    e.offsets.push(e.offsets.at(-1) - size)
                }
                advance(3, total_mem)
            }
            total_mem -= size
        }
        max_size = Math.max(total_mem, max_size)
    }

    for (const elem of current_data) {
        elem.timesteps.push(timestep)
        elem.offsets.push(elem.offsets.at(-1))
    }
    return {
        max_size: max_size,
        allocations_over_time: data,
        max_at_time: max_at_time,
        context_for_id:  (elem) => {
            let strings = []
            let id = alloc_data.elements[elem].info
            while (id !== null) {
                const [sid, next_id] = alloc_data.suffix_table[id]
                strings.push(alloc_data.string_table[sid])
                id = next_id
            }
            return `${strings.join('\n')}\n`
        }
    }
}

function MemoryPlot(svg, data, left_pad, colors=schemeTableau10) {
    function format_points(d) {
        const size = d.size
        const xs = d.timesteps.map(t => xscale(t))
        const bottom = d.offsets.map(t => yscale(t))
        const top = d.offsets.map(t => yscale(t + size))

        const p0 = xs.map((x, i) => `${x},${bottom[i]}`)
        const p1 = xs.map((x, i) => `${x},${top[i]}`).reverse()

        return `${p0.join(' ')} ${p1.join(' ')}`
    }

    let max_timestep = data.max_at_time.length
    let max_size = data.max_size

    let width = svg.attr('width')
    let height = svg.attr('height')
    let plot_width = width - left_pad
    let plot_height = height

    let yscale = scaleLinear().domain([0, max_size]).range([plot_height, 0]);
    let heightscale = scaleLinear().domain([0, max_size]).range([0, plot_height]);
    let yaxis = axisLeft(yscale).tickFormat(d3.format("~s"))
    let xscale = scaleLinear().domain([0, max_timestep]).range([0, plot_width])
    let plot_coordinate_space = svg.append("g").attr("transform", `translate(${left_pad}, ${0})`)
    let plot_outer = plot_coordinate_space.append('g')

    function view_rect(a) {
        return a.append('rect').attr('x', 0).attr('y', 0)
                .attr('width', plot_width).attr('height', plot_height)
                .attr('fill', 'white')
    }

    view_rect(plot_outer)

    let cp = svg.append("clipPath").attr("id", "clip")
    view_rect(cp)
    plot_outer.attr('clip-path', "url(#clip)")


    let zoom_group = plot_outer.append("g")
    let scrub_group = zoom_group.append('g')

    let plot = scrub_group.selectAll("polygon")
    .data(data.allocations_over_time)
    .enter()
    .append("polygon")
    .attr('points', format_points)
    .attr('fill', d => colors[d.elem % colors.length])

    let axis = plot_coordinate_space.append('g').call(yaxis)


    let scale_mini = 0
    let translate_mini = 0
    function handleZoom(e) {
        const t = e.transform
        zoom_group.attr("transform", t)
        axis.call(yaxis.scale(e.transform.rescaleY(yscale)))
    }

    const thezoom = zoom().on('zoom', handleZoom)
    plot_outer.call(thezoom)

    return {
        select_window: (stepbegin, stepend, max) => {
            let begin = xscale(stepbegin)
            let size = xscale(stepend) - xscale(stepbegin);
            let scale = plot_width / size
            let translate = -begin
            let yscale =  max_size/max
            scrub_group.attr("transform", `scale(${scale/yscale}, 1) translate(${translate}, 0)`)
            plot_outer.call(thezoom.transform, zoomIdentity.scale(yscale).translate(0, -(plot_height - plot_height/yscale)))
        },
        set_delegate: (delegate) => {
            plot.on('mouseover', function (e, d) { delegate.set_selected(d3.select(this)) } )
            .on('mousedown', function(e, d) { delegate.default_selected = d3.select(this)})
            .on('mouseleave', function (e, d) { delegate.set_selected(delegate.default_selected) } )
        }
    }
}

function ContextViewer(text, data) {
    let current_selected = null

    return {
        default_selected: null,
        set_selected: (d) => {
            if (current_selected !== null) {
                current_selected.attr('stroke', null).attr('stroke-width', null);
            }
            if (d === null) {
                text.text("")
            } else {
                const dd = d.datum()
                text.text(`${dd.elem} ${data.context_for_id(dd.elem)}`)
                d.attr('stroke', 'black').attr('stroke-width', 1).attr('vector-effect', 'non-scaling-stroke')
            }
            current_selected = d
        }
    }
}


function MiniMap(mini_svg, plot, data, left_pad, height=70) {
    let max_at_time = data.max_at_time
    let width = mini_svg.attr('width')
    let plot_width = width - left_pad
    let yscale = scaleLinear().domain([0, data.max_size]).range([height, 0]);
    let minixscale = scaleLinear().domain([0, max_at_time.length]).range([left_pad, width])

    let mini_points = [[max_at_time.length, 0], [0, 0]]

    for (const [i, m] of max_at_time.entries()) {
        let [lastx, lasty] = mini_points[mini_points.length - 1]
        if (m !== lasty) {
            mini_points.push([i, lasty])
            mini_points.push([i, m])
        } else if (i === max_at_time.length - 1) {
            mini_points.push([i, m])
        }
    }


    let points = mini_points.map(([t, o]) => `${minixscale(t)}, ${yscale(o)}`)
    points = points.join(' ')
    mini_svg.append('polygon').attr('points', points).attr('fill', schemeTableau10[0])

    let xscale = scaleLinear().domain([0, max_at_time.length]).range([0, plot_width])


    const brush = brushX()
    brush.extent([[left_pad, 0], [width, height]])
    brush.on('brush', function({selection}) {
        let [begin, end] = selection.map(x => x - left_pad)

        let stepbegin = Math.floor(xscale.invert(begin))
        let stepend = Math.floor(xscale.invert(end))
        let max = 0
        for (let i = stepbegin; i < stepend; i++) {
            max = Math.max(max, max_at_time[i])
        }
        plot.select_window(stepbegin, stepend, max)
    })
    mini_svg.call(brush)
    return {}
}

let left_pad = 70
let width = 1024
let height = 768
let data = process_alloc_data()
let body = d3.select("body")

let plot = MemoryPlot(body.append("svg").attr('width', width).attr('height', height).attr('display', 'block'), data, left_pad)

MiniMap(body.append("svg").attr('width', width).attr('height', 80).attr('display', 'block'), plot, data, left_pad)
let delegate = ContextViewer(body.append("div").append("pre").text('none'), data)
plot.set_delegate(delegate)

</script>
</body>
</html>
